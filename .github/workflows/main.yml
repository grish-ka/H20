name: Build & Sign H20 Windows Installer

on:
  push:
    tags:
      - 'v*.*.*' # Triggers when a tag like v1.0.0 is pushed
  workflow_dispatch: # Allows manual trigger from GitHub UI

jobs:
  build-and-sign:
    runs-on: windows-latest
    permissions:
      contents: write # To upload release assets
      id-token: write # Required for Sigstore OIDC authentication

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x' # Specify your Python version

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt # Make sure you have a requirements.txt
        pip install pyinstaller # Install pyinstaller

    - name: Package Python Application with PyInstaller
      # This example assumes you want to copy the contents of dist/H20 to an 'app' folder for mpdev
      run: |
        # Clean up old builds (optional but good practice)
        if (Test-Path ".\dist") { Remove-Item -Recurse -Force ".\dist" }
        if (Test-Path ".\build") { Remove-Item -Recurse -Force ".\build" }
        if (Test-Path ".\H20.spec") { Remove-Item -Force ".\H20.spec" }
        if (Test-Path ".\app") { Remove-Item -Recurse -Force ".\app" }

        # Run PyInstaller to create the bundled application (e.g., in dist/H20 folder)
        # Using --onefile since you mentioned no assets, so the .exe will be standalone
        pyinstaller --name H20 --onefile --windowed main.py 

        # Create the 'app' directory
        New-Item -ItemType Directory -Path ".\app"

        # Copy PyInstaller's single executable to the 'app' folder as expected by msi.json
        Copy-Item -Path ".\dist\H20.exe" -Destination ".\app\" -Force

      working-directory: . # Make sure this is your project root where main.py is

    - name: Set up .NET (mpdev is a .NET tool)
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '6.0.x' # Adjust if mpdev requires a different version

    - name: Install Master Packager Dev
      run: dotnet tool install --global mpdev

    - name: Build Installer with mpdev
      run: mpdev build --config msi.json # Your msi.json should now only specify "msi" output
      working-directory: . # Assumes msi.json is at the root of your repo

    - name: List Output Files (for debugging)
      run: |
        Get-ChildItem -Path "OutputMSI" -Recurse

#    # --- Sigstore Signing Step ---
#    - name: Sign MSI with Sigstore
#      uses: sigstore/gh-action-sign@v1 # <--- CHANGED ACTION NAME
#      with:
#        # The 'assets' input takes a space-separated list of files or directories
#        assets: OutputMSI/H20-1.0.0.msi # Still adjust version if needed
#        # No 'files' input for this action, it's 'assets'
        # --- Sigstore Signing Steps (Updated Method) ---
        - name: Set up Cosign
          uses: sigstore/cosign-installer@v3.1.1 # Install the cosign tool
          with:
            cosign-release: 'v2.2.3' # Specify a stable Cosign version

        - name: Get Sigstore Identity Token
          # This step is often implicitly handled by the signing action,
          # but sometimes it helps to explicitly request the token for debugging or complex scenarios.
          # For a simple blob sign, cosign should pick up the OIDC token automatically if permissions are set.
          id: sigstore_identity
          uses: actions/github-script@v6
          with:
            script: |
              const token = await core.getIDToken('https://token.actions.githubusercontent.com');
              core.setOutput('token', token);

        - name: Sign MSI with Cosign
          env:
            COSIGN_REPOSITORY: ghcr.io/${{ github.repository }} # Optional: use GHCR for signatures
            COSIGN_EXPERIMENTAL: "true" # Required for some newer cosign features
          run: |
            # Get the path to your generated MSI
            $msiPath = "OutputMSI/H20-1.0.0.msi" # Adjust version number or use wildcard if mpdev names it dynamically

            # Check if the MSI file exists
            if (-not (Test-Path $msiPath)) {
                Write-Host "MSI file not found at $msiPath. Listing OutputMSI folder for debugging..."
                Get-ChildItem -Path "OutputMSI" -Recurse
                exit 1
            }

            # Sign the MSI file as a blob using cosign.
            # This will upload the signature to Rekor and potentially store metadata.
            # The OIDC token from GitHub Actions will be used for authentication.
            cosign sign-blob --output-signature "$($msiPath).sig" --output-attestation "$($msiPath).att" --yes "$msiPath"

            # The signature and attestation files are now created alongside your MSI
            # You can choose to upload these to the release as well, or just rely on Rekor.

    # --- Release Creation and Asset Upload ---
    - name: Create GitHub Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false

    - name: Upload MSI to Release
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: OutputMSI/H20-1.0.0.msi # Path to the signed MSI
        asset_name: H20-${{ github.ref_name }}.msi # Naming the asset
        asset_content_type: application/x-msi
